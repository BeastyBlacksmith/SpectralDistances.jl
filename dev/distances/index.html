<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distances · SpectralDistances</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpectralDistances</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SpectralDistances</a></li><li><a class="tocitem" href="../ltimodels/">Models and root manipulations</a></li><li class="is-active"><a class="tocitem" href>Distances</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#A-full-example-1"><span>A full example</span></a></li><li><a class="tocitem" href="#Using-Welch-periodograms-1"><span>Using Welch periodograms</span></a></li><li><a class="tocitem" href="#Function-reference-1"><span>Function reference</span></a></li><li><a class="tocitem" href="#Docstrings-1"><span>Docstrings</span></a></li><li><a class="tocitem" href="#Details-1"><span>Details</span></a></li></ul></li><li><a class="tocitem" href="../interpolations/">Interpolations and Barycenters</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../misc/">Misc.</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Distances</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distances</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/distances.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Distances-1"><a class="docs-heading-anchor" href="#Distances-1">Distances</a><a class="docs-heading-anchor-permalink" href="#Distances-1" title="Permalink"></a></h1><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>The following is a reference on all the distances defined in this package. Once a distance is defined, it can be evaluated in one of two ways, defined by the  <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> interface</p><pre><code class="language-julia">dist = DistanceType(options)
d = evaluate(d, x1, x2)
d = dist(x1, x2)</code></pre><p>Before we proceed, the following distances are available</p><ul><li><a href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a></li><li><a href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a></li><li><a href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a></li><li><a href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a></li><li><a href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a></li><li><a href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a></li><li><a href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a></li><li><a href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a></li><li><a href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a></li><li><a href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a></li><li><a href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a></li><li><a href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a></li><li><a href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.SinkhornRootDistance"><code>SpectralDistances.SinkhornRootDistance</code></a></li><li><a href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a></li><li><a href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a></li></ul><p>Some of these distances operate directly on signals, these are</p><pre><code class="language-none">EnergyDistance
ModelDistance
SpectralDistances.AbstractWelchDistance</code></pre><p>Of these, <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> is a bit special, works like this</p><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ModelDistance" href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelDistance{D &lt;: AbstractDistance} &lt;: AbstractSignalDistance</code></pre><p>A model distance operates on signals and works by fitting an LTI model to the signals before calculating the distance. The distance between the LTI models is defined by the field <code>distance</code>. This is essentially a wrapper around the inner distance that handles the fitting of a model to the signals. How the model is fit is determined by <code>fitmethod</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>fitmethod::</code><a href="../ltimodels/#SpectralDistances.FitMethod"><code>FitMethod</code></a>: <a href="../ltimodels/#SpectralDistances.LS"><code>LS</code></a>, <a href="../ltimodels/#SpectralDistances.TLS"><code>TLS</code></a> or <a href="../ltimodels/#SpectralDistances.PLR"><code>PLR</code></a></li><li><code>distance::D</code>: The inner distance between the models</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances
innerdistance = SinkhornRootDistance(domain=Continuous(), β=0.005, p=2)
dist = ModelDistance(TLS(na=30), innerdistance)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L48-L63">source</a></section></article><p>The inner distance in <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> can be any <a href="#SpectralDistances.AbstractRationalDistance"><code>AbstractRationalDistance</code></a>. The options are</p><pre><code class="language-none">DiscretizedRationalDistance
RationalCramerDistance
RationalOptimalTransportDistance
SpectralDistances.AbstractCoefficientDistance
SpectralDistances.AbstractRootDistance</code></pre><p>These distances operate on LTI models. Some operate on the coefficients of the models</p><pre><code class="language-none">CoefficientDistance</code></pre><p>and some operate on the roots of the models</p><pre><code class="language-none">EuclideanRootDistance
HungarianRootDistance
KernelWassersteinRootDistance
SinkhornRootDistance</code></pre><h2 id="A-full-example-1"><a class="docs-heading-anchor" href="#A-full-example-1">A full example</a><a class="docs-heading-anchor-permalink" href="#A-full-example-1" title="Permalink"></a></h2><p>To use the <a href="#SpectralDistances.SinkhornRootDistance"><code>SinkhornRootDistance</code></a> and let it operate on signals, we may construct our distance object as follows</p><pre><code class="language-julia-repl">julia&gt; innerdistance = SinkhornRootDistance(domain=Continuous(), β=0.005, p=2)
SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#64#65&quot;{typeof(s1),typeof(residueweight)}}(Continuous(), identity, Base.var&quot;#64#65&quot;{typeof(s1),typeof(residueweight)}(SpectralDistances.s1, SpectralDistances.residueweight), 0.005, 10000, 2)

julia&gt; dist = ModelDistance(TLS(na=30), innerdistance)
ModelDistance{SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#64#65&quot;{typeof(s1),typeof(residueweight)}}}(TLS(30), SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#64#65&quot;{typeof(s1),typeof(residueweight)}}(Continuous(), identity, Base.var&quot;#64#65&quot;{typeof(s1),typeof(residueweight)}(SpectralDistances.s1, SpectralDistances.residueweight), 0.005, 10000, 2))

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
0.10235013706213042

julia&gt; dist = ModelDistance(LS(na=2), innerdistance);

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
0.0005614882602621433

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.004004572174828461</code></pre><h2 id="Using-Welch-periodograms-1"><a class="docs-heading-anchor" href="#Using-Welch-periodograms-1">Using Welch periodograms</a><a class="docs-heading-anchor-permalink" href="#Using-Welch-periodograms-1" title="Permalink"></a></h2><p>We can calculate the Wasserstein distance between spectra estimated using the Welch method like so</p><pre><code class="language-julia-repl">julia&gt; dist = WelchOptimalTransportDistance(p=2)
WelchOptimalTransportDistance{Nothing,Tuple{},NamedTuple{(),Tuple{}}}(nothing, 0.01, 10000, (), NamedTuple(), 2)

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
6.52866012789419e-5

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
8.82304320888033e-5

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.00029130696022825863</code></pre><h2 id="Function-reference-1"><a class="docs-heading-anchor" href="#Function-reference-1">Function reference</a><a class="docs-heading-anchor-permalink" href="#Function-reference-1" title="Permalink"></a></h2><ul><li><a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a></li><li><a href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a></li><li><a href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a></li><li><a href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a></li><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a></li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a></li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a></li></ul><h2 id="Docstrings-1"><a class="docs-heading-anchor" href="#Docstrings-1">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractDistance" href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The top level distance type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractRationalDistance" href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on rational transfer functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.AbstractSignalDistance" href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All subtypes of this type operates on signals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.BuresDistance" href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuresDistance &lt;: AbstractDistance</code></pre><p>Distance between pos.def. matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.CoefficientDistance" href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoefficientDistance{D, ID} &lt;: AbstractCoefficientDistance</code></pre><p>Distance metric based on model coefficients</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance between coeffs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.DiscretizedRationalDistance" href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscretizedRationalDistance{WT, DT} &lt;: AbstractRationalDistance</code></pre><p>This distance discretizes the spectrum before performing the calculations.</p><p><strong>Arguments:</strong></p><ul><li><code>w::WT = LinRange(0.01, 0.5, 300)</code>: Frequency set</li><li><code>distmat::DT = distmat_euclidean(w, w)</code>: DESCRIPTION</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EnergyDistance" href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EnergyDistance &lt;: AbstractSignalDistance</code></pre><p><code>std(x1) - std(x2)</code> This distance can be added to a loss function to ensure that the energy in the two signals is the same. Some of the optimal transport-based distances are invariant to the energy in the signal, requiring this extra cost if that invariance is not desired. Combining distances is done by putting two or more in a tuple.     Usage: <code>combined_loss = (primary_distance, EnergyDistance())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L264-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.EuclideanRootDistance" href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EuclideanRootDistance{D, A, F1, F2} &lt;: AbstractRootDistance</code></pre><p>Simple euclidean distance between roots of transfer functions</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>assignment::A =</code> <a href="../ltimodels/#SpectralDistances.SortAssignement"><code>SortAssignement</code></a><code>(imag)</code>: Determines how roots are assigned. An alternative is <code>HungarianAssignement</code></li><li><code>transform::F1 = identity</code>: DESCRIPTION</li><li><code>weight</code> : A function used to calculate weights for the induvidual root distances. A good option is <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a></li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L69-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.HungarianRootDistance" href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HungarianRootDistance{D, ID &lt;: Distances.PreMetric, F} &lt;: AbstractRootDistance</code></pre><p>Similar to <a href="#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> but does the pole assignment using the Hungarian method.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L113-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.KernelWassersteinRootDistance" href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KernelWassersteinRootDistance{D, F, DI} &lt;: AbstractRootDistance</code></pre><p>A kernel version of the root distance</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>λ::Float64 = 1.0</code>: Kernel precision, lower value means wider kernel.</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li><li><code>distance::DI = SqEuclidean()</code>: Inner distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.OptimalTransportHistogramDistance" href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimalTransportHistogramDistance{DT} &lt;: AbstractDistance</code></pre><p>What it sounds like</p><p><strong>Arguments:</strong></p><ul><li><code>p::Int = 1</code>: order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L206-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalCramerDistance" href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RationalCramerDistance{DT} &lt;: AbstractRationalDistance</code></pre><p>Similar to <code>RationalOptimalTransportDistance</code> but does not use inverse functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 2</code>: order</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.RationalOptimalTransportDistance" href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RationalOptimalTransportDistance{DT, MT} &lt;: AbstractRationalDistance</code></pre><p>calculates the Wasserstein distance using the closed-form solution based on integrals and inverse cumulative functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 1</code>: order</li><li><code>magnitude::MT = Identity()</code>:</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L219-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.SinkhornRootDistance" href="#SpectralDistances.SinkhornRootDistance"><code>SpectralDistances.SinkhornRootDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SinkhornRootDistance{D, F1, F2} &lt;: AbstractRootDistance</code></pre><p>The Sinkhorn distance between roots. The weights are provided by <code>weight</code>, which defaults to <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>transform::F1 = identity</code>: Probably not needed.</li><li><code>weight::F2 =</code><a href="../misc/#SpectralDistances.s1"><code>s1</code></a> <code>∘</code> <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>: A function used to calculate weights for the induvidual root distances.</li><li><code>β::Float64 = 0.01</code>: Amount of entropy regularization</li><li><code>iters::Int = 10000</code>: Number of iterations of the Sinkhorn algorithm.</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchLPDistance" href="#SpectralDistances.WelchLPDistance"><code>SpectralDistances.WelchLPDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchLPDistance{AT &lt;: Tuple, KWT &lt;: NamedTuple, F} &lt;: AbstractWelchDistance</code></pre><p>Lᵖ distance between welch spectra, <code>mean(abs(x1-x2)^p)</code>.</p><p>#Arguments:</p><ul><li><code>args::AT = ()</code>: These are sent to <code>welch_pgram</code></li><li><code>kwargs::KWT = NamedTuple()</code>: These are sent to <code>welch_pgram</code></li><li><code>p::Int = 2</code>: Order of the distance</li><li><code>normalized::Bool = true</code>: Normlize spectrum to sum to 1 (recommended)</li><li><code>transform::F = identity</code>: Optional function to apply to the spectrum, example <code>log1p</code> or <code>sqrt</code>. Must not produce negative values, so <code>log</code> is not a good idea. The function is applied like this: <code>transform.(x1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L185-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.WelchOptimalTransportDistance" href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WelchOptimalTransportDistance{DT, AT &lt;: Tuple, KWT &lt;: NamedTuple} &lt;: AbstractWelchDistance</code></pre><p>Calculates the Wasserstein distance between two signals by estimating a Welch periodogram of each.</p><p><strong>Arguments:</strong></p><ul><li><code>distmat::DT</code>: you may provide a matrix array for this</li><li><code>args::AT = ()</code>: Options to the Welch function</li><li><code>kwargs::KWT = NamedTuple()</code>: Options to the Welch function</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L164-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T" href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">discrete_grid_transportplan(x::AbstractVector{T}, y::AbstractVector{T}, tol=sqrt(eps(T))) where T</code></pre><p>Calculate the optimal-transport plan between two vectors that are assumed to have the same support, with sorted support points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L564-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain-Tuple{Any}" href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain(d::AbstractDistance)</code></pre><pre><code class="language-julia">domain(d::Any) -&gt; Discrete
</code></pre><p>Return the domain of the distance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}" href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">domain_transform(d::AbstractDistance, e)</code></pre><p>Change domain of roots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.precompute" href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">precompute(d::AbstractDistance, As, threads=true)</code></pre><p>Perform computations that only need to be donce once when several pairwise distances are to be computed</p><p><strong>Arguments:</strong></p><ul><li><code>As</code>: A vector of models</li><li><code>threads</code>: Us multithreading? (true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/losses.jl#L493-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.IPOT-Tuple{Any,Any,Any}" href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">γ, u, v = IPOT(C, a, b; β=1, iters=1000)</code></pre><p>The Inexact Proximal point method for exact Optimal Transport problem (IPOT) (Sinkhorn-like) algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>. <code>β</code> does not have to go to 0 for this alg to return the optimal distance, in fact, if β is set too low, this alg will encounter numerical problems.</p><p>A Fast Proximal Point Method for Computing Exact Wasserstein Distance Yujia Xie, Xiangfeng Wang, Ruijia Wang, Hongyuan Zha https://arxiv.org/abs/1802.04307</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/sinkhorn.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">γ, u, v = sinkhorn(C, a, b; β=1e-1, iters=1000)</code></pre><p>The Sinkhorn algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. This function is relatively slow, see also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> <a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> and <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> for faster algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/sinkhorn.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same as <a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a> but operates in-place to save memory allocations. This function has higher performance than <code>sinkhorn_log</code>, but might not work as well with AD libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/sinkhorn.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn_log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">γ, u, v = sinkhorn_log(C, a, b; β=1e-1, iters=1000, tol=1e-8)</code></pre><p>The Sinkhorn algorithm (log-stabilized). <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a> for a faster implementation operating in-place, and <a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> for a potentially more exact solution.</p><p>https://arxiv.org/pdf/1610.06519.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/sinkhorn.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpectralDistances.ot_jump-Tuple{Any,Any,Any}" href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>SpectralDistances.ot_jump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ot_jump(D, P1, P2)</code></pre><p>Solve the optimal transport problem using JuMP. This function is only available if <code>using JuMP, GLPK</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>D</code>: Distance matrix</li><li><code>P1</code>: Weight vector 1</li><li><code>P2</code>: Weight vector 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/9db45ca8f78477149ae733a12947a6f9b25ce44a/src/jump.jl#L3-L12">source</a></section></article><h2 id="Details-1"><a class="docs-heading-anchor" href="#Details-1">Details</a><a class="docs-heading-anchor-permalink" href="#Details-1" title="Permalink"></a></h2><p>Transport-based distances may require some tuning parameters to be set for the solvers. The available solvers are</p><ul><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>: not recommended due to numerical issues, but this is the standard algorithm.</li><li><a href="#SpectralDistances.sinkhorn_log-Tuple{Any,Any,Any}"><code>sinkhorn_log</code></a>: better numerical stability than the standard.</li><li><a href="#SpectralDistances.sinkhorn_log!-Tuple{Any,Any,Any}"><code>sinkhorn_log!</code></a>: in-place version that is faster, but some AD libraries might not like it.</li><li><a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a> Finds exact solution (without entropy regularization), requires β around 0.1-1.</li><li><a href="#SpectralDistances.ot_jump-Tuple{Any,Any,Any}"><code>ot_jump</code></a>: exact solution using JuMP, requires <code>using JuMP, GLPK</code> before it becomes available.</li></ul><h3 id="Providing-solver-and-options-1"><a class="docs-heading-anchor" href="#Providing-solver-and-options-1">Providing solver and options</a><a class="docs-heading-anchor-permalink" href="#Providing-solver-and-options-1" title="Permalink"></a></h3><pre><code class="language-julia">options = (solver=sinkhorn_log!, tol=1e-6, iters=100_000)
distance = SinkhornRootDistance(domain=Continuous(), p=1, β=0.001)
SpectralDistances.evaluate(distance, model1, model2; options...)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ltimodels/">« Models and root manipulations</a><a class="docs-footer-nextpage" href="../interpolations/">Interpolations and Barycenters »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 25 March 2020 23:58">Wednesday 25 March 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
