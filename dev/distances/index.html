<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distances · SpectralDistances</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SpectralDistances</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">SpectralDistances</a></li><li><a class="toctext" href="../ltimodels/">Models and root manipulations</a></li><li class="current"><a class="toctext" href>Distances</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#A-full-example-1">A full example</a></li><li><a class="toctext" href="#Using-Welch-periodograms-1">Using Welch periodograms</a></li><li><a class="toctext" href="#Function-reference-1">Function reference</a></li><li><a class="toctext" href="#Docstrings-1">Docstrings</a></li></ul></li><li><a class="toctext" href="../interpolations/">Interpolations</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../misc/">Misc.</a></li><li><a class="toctext" href="../examples/">Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Distances</a></li></ul><a class="edit-page" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/master/docs/src/distances.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Distances</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Distances-1" href="#Distances-1">Distances</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>The following is a reference on all the distances defined in this package. Once a distance is defined, it can be evaluated in one of two ways, defined by the  <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> interface</p><pre><code class="language-julia">dist = DistanceType(options)
d = evaluate(d, x1, x2)
d = dist(x1, x2)</code></pre><p>Before we proceed, the following distances are available</p><ul><li><a href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a></li><li><a href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a></li><li><a href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a></li><li><a href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a></li><li><a href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a></li><li><a href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a></li><li><a href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a></li><li><a href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a></li><li><a href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a></li><li><a href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a></li><li><a href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a></li><li><a href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a></li><li><a href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a></li><li><a href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a></li><li><a href="#SpectralDistances.SinkhornRootDistance"><code>SpectralDistances.SinkhornRootDistance</code></a></li><li><a href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a></li></ul><div></div><p>Some of these distances operate directly on signals, these are</p><pre><code class="language-none">EnergyDistance
ModelDistance
WelchOptimalTransportDistance</code></pre><p>Of these, <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> is a bit special, works like this</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.ModelDistance" href="#SpectralDistances.ModelDistance"><code>SpectralDistances.ModelDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ModelDistance{D &lt;: AbstractDistance} &lt;: AbstractSignalDistance</code></pre><p>A model distance operates on signals and works by fitting an LTI model to the signals before calculating the distance. The distance between the LTI models is defined by the field <code>distance</code>. This is essentially a wrapper around the inner distance that handles the fitting of a model to the signals. How the model is fit is determined by <code>fitmethod</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>fitmethod::</code><a href="@ref"><code>FitMethod</code></a>: <a href="../ltimodels/#SpectralDistances.LS"><code>LS</code></a>, <a href="../ltimodels/#SpectralDistances.TLS"><code>TLS</code></a> or <a href="../ltimodels/#SpectralDistances.PLR"><code>PLR</code></a></li><li><code>distance::D</code>: The inner distance between the models</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">using SpectralDistances
innerdistance = SinkhornRootDistance(domain=Continuous(), β=0.005, p=2)
dist = ModelDistance(TLS(na=30), innerdistance)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L47-L62">source</a></section><p>The inner distance in <a href="#SpectralDistances.ModelDistance"><code>ModelDistance</code></a> can be any <a href="#SpectralDistances.AbstractRationalDistance"><code>AbstractRationalDistance</code></a>. The options are</p><pre><code class="language-none">DiscretizedRationalDistance
RationalCramerDistance
RationalOptimalTransportDistance
SpectralDistances.AbstractCoefficientDistance
SpectralDistances.AbstractRootDistance</code></pre><p>These distances operate on LTI models. Some operate on the coefficients of the models</p><pre><code class="language-none">CoefficientDistance</code></pre><p>and some operate on the roots of the models</p><pre><code class="language-none">EuclideanRootDistance
HungarianRootDistance
KernelWassersteinRootDistance
SinkhornRootDistance</code></pre><h2><a class="nav-anchor" id="A-full-example-1" href="#A-full-example-1">A full example</a></h2><p>To use the <a href="#SpectralDistances.SinkhornRootDistance"><code>SinkhornRootDistance</code></a> and let it operate on signals, we may construct our distance object as follows</p><pre><code class="language-julia-repl">julia&gt; innerdistance = SinkhornRootDistance(domain=Continuous(), β=0.005, p=2)
SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#56#57&quot;{typeof(s1),typeof(residueweight)}}(Continuous(), identity, Base.var&quot;#56#57&quot;{typeof(s1),typeof(residueweight)}(SpectralDistances.s1, SpectralDistances.residueweight), 0.005, 10000, 2)

julia&gt; dist = ModelDistance(TLS(na=30), innerdistance)
ModelDistance{SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#56#57&quot;{typeof(s1),typeof(residueweight)}}}(TLS(30), SinkhornRootDistance{Continuous,typeof(identity),Base.var&quot;#56#57&quot;{typeof(s1),typeof(residueweight)}}(Continuous(), identity, Base.var&quot;#56#57&quot;{typeof(s1),typeof(residueweight)}(SpectralDistances.s1, SpectralDistances.residueweight), 0.005, 10000, 2))

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
┌ Warning: Roots on negative real axis, no corresponding continuous time representation exists.
└ @ SpectralDistances ~/build/baggepinnen/SpectralDistances.jl/src/ltimodels.jl:56
0.09224411089999843

julia&gt; dist = ModelDistance(LS(na=2), innerdistance);

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
0.0005614882602620935

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.004004572174828294</code></pre><h2><a class="nav-anchor" id="Using-Welch-periodograms-1" href="#Using-Welch-periodograms-1">Using Welch periodograms</a></h2><p>We can calculate the Wasserstein distance between spectra estimated using the Welch method like so</p><pre><code class="language-julia-repl">julia&gt; dist = WelchOptimalTransportDistance(p=2)
WelchOptimalTransportDistance{Nothing,Tuple{},NamedTuple{(),Tuple{}}}(nothing, 0.01, 10000, (), NamedTuple(), 2)

julia&gt; X1, X2 = randn(1000), randn(1000);

julia&gt; dist(X1,X2)
0.00013034949409317646

julia&gt; t = 0:0.01:10;

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*1.1 .*t); # Two signals that are close in frequency

julia&gt; dist(X1,X2)
8.823043208878249e-5

julia&gt; X1, X2 = sin.(2π*1 .*t), sin.(2π*2 .*t);   # Two signals that are further apart in frequency

julia&gt; dist(X1,X2)
0.00029130696022822513</code></pre><h2><a class="nav-anchor" id="Function-reference-1" href="#Function-reference-1">Function reference</a></h2><ul><li><a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a></li><li><a href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a></li><li><a href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a></li><li><a href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a></li><li><a href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a></li><li><a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a></li></ul><h2><a class="nav-anchor" id="Docstrings-1" href="#Docstrings-1">Docstrings</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.AbstractDistance" href="#SpectralDistances.AbstractDistance"><code>SpectralDistances.AbstractDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The top level distance type</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.AbstractRationalDistance" href="#SpectralDistances.AbstractRationalDistance"><code>SpectralDistances.AbstractRationalDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>All subtypes of this type operates on rational transfer functions</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.AbstractSignalDistance" href="#SpectralDistances.AbstractSignalDistance"><code>SpectralDistances.AbstractSignalDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>All subtypes of this type operates on signals</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.BuresDistance" href="#SpectralDistances.BuresDistance"><code>SpectralDistances.BuresDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BuresDistance &lt;: AbstractDistance</code></pre><p>Distance between pos.def. matrices</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L234-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.CoefficientDistance" href="#SpectralDistances.CoefficientDistance"><code>SpectralDistances.CoefficientDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CoefficientDistance{D, ID} &lt;: AbstractCoefficientDistance</code></pre><p>Distance metric based on model coefficients</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance between coeffs</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L32-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.DiscretizedRationalDistance" href="#SpectralDistances.DiscretizedRationalDistance"><code>SpectralDistances.DiscretizedRationalDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscretizedRationalDistance{WT, DT} &lt;: AbstractRationalDistance</code></pre><p>This distance discretizes the spectrum before performing the calculations.</p><p><strong>Arguments:</strong></p><ul><li><code>w::WT = LinRange(0.01, 0.5, 300)</code>: Frequency set</li><li><code>distmat::DT = distmat_euclidean(w, w)</code>: DESCRIPTION</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L148-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.EnergyDistance" href="#SpectralDistances.EnergyDistance"><code>SpectralDistances.EnergyDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EnergyDistance &lt;: AbstractSignalDistance</code></pre><p><code>std(x1) - std(x2)</code> This distance can be added to a loss function to ensure that the energy in the two signals is the same. Some of the optimal transport-based distances are invariant to the energy in the signal, requiring this extra cost if that invariance is not desired. Combining distances is done by putting two or more in a tuple.     Usage: <code>combined_loss = (primary_distance, EnergyDistance())</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L242-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.EuclideanRootDistance" href="#SpectralDistances.EuclideanRootDistance"><code>SpectralDistances.EuclideanRootDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EuclideanRootDistance{D, A, F1, F2} &lt;: AbstractRootDistance</code></pre><p>Simple euclidean distance between roots of transfer functions</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>assignment::A =</code> <a href="../ltimodels/#SpectralDistances.SortAssignement"><code>SortAssignement</code></a><code>(imag)</code>: Determines how roots are assigned. An alternative is <code>HungarianAssignement</code></li><li><code>transform::F1 = identity</code>: DESCRIPTION</li><li><code>weight</code> : A function used to calculate weights for the induvidual root distances. A good option is <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a></li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L68-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.HungarianRootDistance" href="#SpectralDistances.HungarianRootDistance"><code>SpectralDistances.HungarianRootDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HungarianRootDistance{D, ID &lt;: Distances.PreMetric, F} &lt;: AbstractRootDistance</code></pre><p>Similar to <a href="#SpectralDistances.EuclideanRootDistance"><code>EuclideanRootDistance</code></a> but does the pole assignment using the Hungarian method.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>distance::ID = SqEuclidean()</code>: Inner distance</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L112-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.KernelWassersteinRootDistance" href="#SpectralDistances.KernelWassersteinRootDistance"><code>SpectralDistances.KernelWassersteinRootDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">KernelWassersteinRootDistance{D, F, DI} &lt;: AbstractRootDistance</code></pre><p>A kernel version of the root distance</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>λ::Float64 = 1.0</code>: Kernel precision, lower value means wider kernel.</li><li><code>transform::F = identity</code>: If provided, this Function transforms all roots before the distance is calculated</li><li><code>distance::DI = SqEuclidean()</code>: Inner distance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L129-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.OptimalTransportHistogramDistance" href="#SpectralDistances.OptimalTransportHistogramDistance"><code>SpectralDistances.OptimalTransportHistogramDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OptimalTransportHistogramDistance{DT} &lt;: AbstractDistance</code></pre><p>What it sounds like</p><p><strong>Arguments:</strong></p><ul><li><code>p::Int = 1</code>: order</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L184-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.RationalCramerDistance" href="#SpectralDistances.RationalCramerDistance"><code>SpectralDistances.RationalCramerDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RationalCramerDistance{DT} &lt;: AbstractRationalDistance</code></pre><p>Similar to <code>RationalOptimalTransportDistance</code> but does not use inverse functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 2</code>: order</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L217-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.RationalOptimalTransportDistance" href="#SpectralDistances.RationalOptimalTransportDistance"><code>SpectralDistances.RationalOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RationalOptimalTransportDistance{DT, MT} &lt;: AbstractRationalDistance</code></pre><p>calculates the Wasserstein distance using the closed-form solution based on integrals and inverse cumulative functions.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::DT</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>p::Int = 1</code>: order</li><li><code>magnitude::MT = Identity()</code>:</li><li><code>interval = (-(float(π)), float(π))</code>: Integration interval</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L197-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.SinkhornRootDistance" href="#SpectralDistances.SinkhornRootDistance"><code>SpectralDistances.SinkhornRootDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SinkhornRootDistance{D, F1, F2} &lt;: AbstractRootDistance</code></pre><p>The Sinkhorn distance between roots. The weights are provided by <code>weight</code>, which defaults to <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>.</p><p><strong>Arguments:</strong></p><ul><li><code>domain::D</code>: <a href="../ltimodels/#SpectralDistances.Discrete"><code>Discrete</code></a> or <a href="../ltimodels/#SpectralDistances.Continuous"><code>Continuous</code></a></li><li><code>transform::F1 = identity</code>: Probably not needed.</li><li><code>weight::F2 =</code><a href="../misc/#SpectralDistances.s1"><code>s1</code></a> <code>∘</code> <a href="../ltimodels/#SpectralDistances.residueweight-Tuple{SpectralDistances.AbstractRoots}"><code>residueweight</code></a>: A function used to calculate weights for the induvidual root distances.</li><li><code>β::Float64 = 0.01</code>: Amount of entropy regularization</li><li><code>iters::Int = 10000</code>: Number of iterations of the Sinkhorn algorithm.</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L89-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.WelchOptimalTransportDistance" href="#SpectralDistances.WelchOptimalTransportDistance"><code>SpectralDistances.WelchOptimalTransportDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">WelchOptimalTransportDistance{DT, AT &lt;: Tuple, KWT &lt;: NamedTuple} &lt;: AbstractSignalDistance</code></pre><p>Calculates the Wasserstein distance between two signals by estimating a Welch periodogram of each.</p><p><strong>Arguments:</strong></p><ul><li><code>distmat::DT</code>: you may provide a matrix array for this</li><li><code>args::AT = ()</code>: Options to the Welch function</li><li><code>kwargs::KWT = NamedTuple()</code>: Options to the Welch function</li><li><code>p::Int = 2</code> : Order of the distance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L163-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T" href="#SpectralDistances.discrete_grid_transportplan-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}, Tuple{AbstractArray{T,1},AbstractArray{T,1},Any}} where T"><code>SpectralDistances.discrete_grid_transportplan</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">discrete_grid_transportplan(x::AbstractVector{T}, y::AbstractVector{T}, tol=sqrt(eps(T))) where T</code></pre><p>Calculate the optimal-transport plan between two vectors that are assumed to have the same support, with sorted support points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L504-L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.domain-Tuple{Any}" href="#SpectralDistances.domain-Tuple{Any}"><code>SpectralDistances.domain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domain(d::AbstractDistance)</code></pre><p>Return the domain of the distance</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L253-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}" href="#SpectralDistances.domain_transform-Tuple{AbstractDistance,Any}"><code>SpectralDistances.domain_transform</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domain_transform(d::AbstractDistance, e)</code></pre><p>Change domain of roots</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L262-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.precompute" href="#SpectralDistances.precompute"><code>SpectralDistances.precompute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">precompute(d::AbstractDistance, As, threads=true)</code></pre><p>Perform computations that only need to be donce once when several pairwise distances are to be computed</p><p><strong>Arguments:</strong></p><ul><li><code>As</code>: A vector of models</li><li><code>threads</code>: Us multithreading? (true)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/losses.jl#L438-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.IPOT-Tuple{Any,Any,Any}" href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>SpectralDistances.IPOT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">γ, u, v = IPOT(C, a, b; β=1, iters=1000)</code></pre><p>The Inexact Proximal point method for exact Optimal Transport problem (IPOT) (Sinkhorn-like) algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>sinkhorn</code></a>. <code>β</code> does not have to go to 0 for this alg to return the optimal distance.</p><p>A Fast Proximal Point Method for Computing Exact Wasserstein Distance Yujia Xie, Xiangfeng Wang, Ruijia Wang, Hongyuan Zha https://arxiv.org/abs/1802.04307</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/sinkhorn.jl#L19-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SpectralDistances.sinkhorn-Tuple{Any,Any,Any}" href="#SpectralDistances.sinkhorn-Tuple{Any,Any,Any}"><code>SpectralDistances.sinkhorn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">γ, u, v = sinkhorn(C, a, b; β=1e-1, iters=1000)</code></pre><p>The Sinkhorn algorithm. <code>C</code> is the cost matrix and <code>a,b</code> are vectors that sum to one. Returns the optimal plan and the dual potentials. See also <a href="#SpectralDistances.IPOT-Tuple{Any,Any,Any}"><code>IPOT</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/SpectralDistances.jl/blob/37f4d0feb9d6e15742e21792570c49b78612d0c6/src/sinkhorn.jl#L1-L5">source</a></section><footer><hr/><a class="previous" href="../ltimodels/"><span class="direction">Previous</span><span class="title">Models and root manipulations</span></a><a class="next" href="../interpolations/"><span class="direction">Next</span><span class="title">Interpolations</span></a></footer></article></body></html>
